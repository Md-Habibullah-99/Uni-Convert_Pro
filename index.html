<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Converter with Compression | Client-side Tool</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    :root {
      --primary: #4361ee;
      --primary-dark: #3a56d4;
      --secondary: #7209b7;
      --light: #f8f9fa;
      --dark: #212529;
      --success: #4cc9f0;
      --warning: #f72585;
      --gray: #6c757d;
      --gray-light: #e9ecef;
      --border-radius: 10px;
      --box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: var(--dark);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 30px 20px;
      margin-bottom: 30px;
    }

    h1 {
      font-size: 2.8rem;
      color: var(--primary);
      margin-bottom: 10px;
    }

    .subtitle {
      font-size: 1.2rem;
      color: var(--gray);
      max-width: 700px;
      margin: 0 auto 20px;
    }

    .highlight {
      color: var(--secondary);
      font-weight: 600;
    }

    .main-content {
      display: flex;
      flex-wrap: wrap;
      gap: 30px;
      margin-bottom: 40px;
    }

    .upload-section,
    .preview-section {
      flex: 1;
      min-width: 300px;
      background-color: white;
      border-radius: var(--border-radius);
      padding: 25px;
      box-shadow: var(--box-shadow);
    }

    .settings-panel {
      flex: 0 0 100%;
      background-color: white;
      border-radius: var(--border-radius);
      padding: 25px;
      box-shadow: var(--box-shadow);
      margin-bottom: 20px;
    }

    .section-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.5rem;
      margin-bottom: 20px;
      color: var(--primary-dark);
      padding-bottom: 10px;
      border-bottom: 2px solid var(--gray-light);
    }

    .section-title i {
      color: var(--secondary);
    }

    .drop-area {
      border: 3px dashed var(--primary);
      border-radius: var(--border-radius);
      padding: 40px 20px;
      text-align: center;
      background-color: var(--gray-light);
      transition: all 0.3s;
      margin-bottom: 20px;
      cursor: pointer;
    }

    .drop-area:hover,
    .drop-area.highlight {
      background-color: #e3f2fd;
      border-color: var(--secondary);
    }

    .drop-area i {
      font-size: 3.5rem;
      color: var(--primary);
      margin-bottom: 15px;
    }

    .file-input {
      display: none;
    }

    .upload-btn {
      display: inline-block;
      background-color: var(--primary);
      color: white;
      padding: 12px 30px;
      border-radius: 50px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      border: none;
      font-size: 1rem;
      margin-top: 15px;
    }

    .upload-btn:hover {
      background-color: var(--primary-dark);
      transform: translateY(-2px);
    }

    .file-info {
      margin-top: 20px;
      padding: 15px;
      background-color: var(--gray-light);
      border-radius: var(--border-radius);
      display: none;
    }

    .file-info.active {
      display: block;
    }

    .file-list {
      list-style-type: none;
      max-height: 200px;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid #ddd;
    }

    .file-item:last-child {
      border-bottom: none;
    }

    .file-name {
      display: flex;
      align-items: center;
      gap: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .file-name i {
      color: var(--primary);
    }

    .file-size {
      font-size: 0.9rem;
      color: var(--gray);
    }

    .remove-file {
      color: var(--warning);
      cursor: pointer;
      background: none;
      border: none;
      font-size: 1.1rem;
    }

    .preview-container {
      height: 400px;
      overflow-y: auto;
      border: 1px solid var(--gray-light);
      border-radius: var(--border-radius);
      padding: 15px;
      background-color: #fafafa;
      margin-bottom: 20px;
    }

    .preview-item {
      background-color: white;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
      border-left: 4px solid var(--primary);
    }

    .preview-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .preview-content {
      max-height: 200px;
      overflow-y: auto;
    }

    .preview-img {
      max-width: 100%;
      max-height: 150px;
      border-radius: 5px;
      display: block;
      margin: 0 auto;
    }

    .preview-text {
      font-family: monospace;
      white-space: pre-wrap;
      font-size: 0.9rem;
      line-height: 1.4;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: space-between;
      margin-top: 20px;
    }

    .control-btn {
      flex: 1;
      min-width: 150px;
      padding: 12px 20px;
      border-radius: var(--border-radius);
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .reorder-btn {
      background-color: var(--gray-light);
      color: var(--dark);
    }

    .reorder-btn:hover {
      background-color: #dee2e6;
    }

    .convert-btn {
      background-color: var(--secondary);
      color: white;
    }

    .convert-btn:hover {
      background-color: #5a08a3;
      transform: translateY(-2px);
    }

    .download-btn {
      background-color: var(--success);
      color: white;
      display: none;
      text-decoration: none;
    }

    .download-btn:hover {
      background-color: #3aa8d0;
      transform: translateY(-2px);
    }

    .memory-warning {
      background-color: #fff3cd;
      color: #856404;
      padding: 15px;
      border-radius: var(--border-radius);
      margin-top: 20px;
      display: none;
      border-left: 4px solid #ffc107;
    }

    .memory-warning.active {
      display: block;
    }

    .warning-icon {
      display: inline-block;
      margin-right: 10px;
      color: #ffc107;
    }

    .loading {
      display: none;
      text-align: center;
      padding: 20px;
    }

    .loading.active {
      display: block;
    }

    .spinner {
      border: 5px solid #f3f3f3;
      border-top: 5px solid var(--primary);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    footer {
      text-align: center;
      padding: 20px;
      color: var(--gray);
      font-size: 0.9rem;
      margin-top: 30px;
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .controls {
        flex-direction: column;
      }

      h1 {
        font-size: 2.2rem;
      }
    }

    .file-type-icon {
      width: 24px;
      text-align: center;
    }

    .item-actions {
      display: flex;
      gap: 10px;
    }

    .move-btn {
      background: none;
      border: none;
      color: var(--gray);
      cursor: pointer;
      font-size: 1.1rem;
    }

    .move-btn:hover {
      color: var(--primary);
    }

    .move-btn:disabled {
      color: #ccc;
      cursor: not-allowed;
    }

    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 15px;
    }

    .setting-group {
      margin-bottom: 15px;
    }

    .setting-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--dark);
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .slider-value {
      min-width: 40px;
      text-align: center;
      font-weight: 600;
      color: var(--primary);
    }

    input[type="range"] {
      flex: 1;
      height: 8px;
      -webkit-appearance: none;
      background: var(--gray-light);
      border-radius: 4px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
    }

    select {
      width: 100%;
      padding: 10px 15px;
      border: 1px solid var(--gray-light);
      border-radius: var(--border-radius);
      background-color: white;
      font-size: 1rem;
      color: var(--dark);
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }

    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .size-estimate {
      background-color: #e7f7ff;
      padding: 12px 15px;
      border-radius: var(--border-radius);
      margin-top: 15px;
      font-size: 0.9rem;
      display: none;
    }

    .size-estimate.active {
      display: block;
    }

    .size-value {
      font-weight: 600;
      color: var(--primary);
    }

    .compression-info {
      font-size: 0.85rem;
      color: var(--gray);
      margin-top: 5px;
    }

    .tab-buttons {
      display: flex;
      border-bottom: 2px solid var(--gray-light);
      margin-bottom: 20px;
    }

    .tab-btn {
      padding: 10px 20px;
      background: none;
      border: none;
      font-weight: 600;
      color: var(--gray);
      cursor: pointer;
      position: relative;
      transition: all 0.3s;
    }

    .tab-btn.active {
      color: var(--primary);
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background-color: var(--primary);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .stats-panel {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: var(--border-radius);
      margin-top: 20px;
      display: none;
    }

    .stats-panel.active {
      display: block;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }

    .stat-item {
      text-align: center;
      padding: 10px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 0.85rem;
      color: var(--gray);
    }

    .quality-badge {
      display: inline-block;
      padding: 3px 8px;
      background-color: var(--primary);
      color: white;
      border-radius: 4px;
      font-size: 0.8rem;
      margin-left: 5px;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>PDF Converter with Compression</h1>
      <p class="subtitle">Convert images and text files to PDF with <span class="highlight">smart compression</span> to
        reduce file size. All processing happens in your browser.</p>
    </header>

    <div class="settings-panel">
      <div class="tab-buttons">
        <button class="tab-btn active" id="compressionTab">Compression Settings</button>
        <button class="tab-btn" id="layoutTab">Layout Settings</button>
      </div>

      <div class="tab-content active" id="compressionSettings">
        <div class="settings-grid">
          <div class="setting-group">
            <label class="setting-label">Image Quality <span class="quality-badge" id="qualityBadge">High</span></label>
            <div class="slider-container">
              <input type="range" id="qualitySlider" min="0.1" max="1" step="0.05" value="0.8">
              <span class="slider-value" id="qualityValue">80%</span>
            </div>
            <p class="compression-info">Lower quality = smaller file size</p>
          </div>

          <div class="setting-group">
            <label class="setting-label">Max Image Width</label>
            <div class="slider-container">
              <input type="range" id="widthSlider" min="400" max="2000" step="100" value="1200">
              <span class="slider-value" id="widthValue">1200px</span>
            </div>
            <p class="compression-info">Larger images will be resized</p>
          </div>

          <div class="setting-group">
            <label class="setting-label">Compression Mode</label>
            <select id="compressionMode">
              <option value="balanced">Balanced (Recommended)</option>
              <option value="high">High Compression</option>
              <option value="low">Low Compression</option>
              <option value="textOnly">Text Only (No Images)</option>
            </select>
          </div>

          <div class="setting-group">
            <label class="setting-label">PDF Format</label>
            <select id="pdfFormat">
              <option value="a4">A4 (Standard)</option>
              <option value="letter">Letter (US)</option>
              <option value="auto">Auto (Fit to content)</option>
            </select>
          </div>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="optimizeImages" checked>
          <label for="optimizeImages">Optimize images before adding to PDF</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="grayscale" unchecked>
          <label for="grayscale">Convert images to grayscale (smaller file)</label>
        </div>

        <div class="size-estimate" id="sizeEstimate">
          <p>Estimated PDF size: <span class="size-value" id="estimatedSize">0 KB</span></p>
          <p class="compression-info">Based on current settings and uploaded files</p>
        </div>
      </div>

      <div class="tab-content" id="layoutSettings">
        <div class="settings-grid">
          <div class="setting-group">
            <label class="setting-label">Page Orientation</label>
            <select id="pageOrientation">
              <option value="portrait">Portrait</option>
              <option value="landscape">Landscape</option>
              <option value="auto">Auto (Based on images)</option>
            </select>
          </div>

          <div class="setting-group">
            <label class="setting-label">Page Margins</label>
            <div class="slider-container">
              <input type="range" id="marginSlider" min="10" max="50" step="5" value="20">
              <span class="slider-value" id="marginValue">20px</span>
            </div>
          </div>

          <div class="setting-group">
            <label class="setting-label">Image Spacing</label>
            <div class="slider-container">
              <input type="range" id="spacingSlider" min="5" max="30" step="5" value="15">
              <span class="slider-value" id="spacingValue">15px</span>
            </div>
          </div>

          <div class="setting-group">
            <label class="setting-label">Text Font Size</label>
            <div class="slider-container">
              <input type="range" id="fontSlider" min="8" max="16" step="1" value="12">
              <span class="slider-value" id="fontValue">12px</span>
            </div>
          </div>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="addPageNumbers" checked>
          <label for="addPageNumbers">Add page numbers</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="addFileNameHeaders" checked>
          <label for="addFileNameHeaders">Add file names as headers</label>
        </div>
      </div>
    </div>

    <div class="main-content">
      <section class="upload-section">
        <h2 class="section-title"><i class="fas fa-cloud-upload-alt"></i> Upload Files</h2>

        <div class="drop-area" id="dropArea">
          <i class="fas fa-file-upload"></i>
          <h3>Drag & Drop Files Here</h3>
          <p>or click to browse</p>
          <p>Supports images (JPG, PNG, WebP, etc.) and text files</p>

          <input type="file" class="file-input" id="fileInput" multiple
            accept=".jpg,.jpeg,.png,.webp,.gif,.bmp,.txt,.text">
          <button class="upload-btn" id="browseBtn">Browse Files</button>
        </div>

        <div class="file-info" id="fileInfo">
          <h4>Selected Files:</h4>
          <ul class="file-list" id="fileList"></ul>
        </div>

        <div class="memory-warning" id="memoryWarning">
          <span class="warning-icon"><i class="fas fa-exclamation-triangle"></i></span>
          <strong>Large File Detected:</strong> Files over 5MB will be compressed to reduce memory usage.
        </div>

        <div class="stats-panel" id="statsPanel">
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-value" id="totalFiles">0</div>
              <div class="stat-label">Total Files</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="totalSize">0 KB</div>
              <div class="stat-label">Original Size</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="estimatedPDF">0 KB</div>
              <div class="stat-label">Estimated PDF</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="compressionRate">0%</div>
              <div class="stat-label">Size Reduction</div>
            </div>
          </div>
        </div>
      </section>

      <section class="preview-section">
        <h2 class="section-title"><i class="fas fa-eye"></i> Preview & Arrange</h2>

        <div class="preview-container" id="previewContainer">
          <p id="emptyPreview">No files added yet. Upload files to see preview here.</p>
        </div>

        <div class="controls">
          <button class="control-btn reorder-btn" id="reorderBtn">
            <i class="fas fa-random"></i> Reorder Files
          </button>

          <button class="control-btn convert-btn" id="convertBtn">
            <i class="fas fa-file-pdf"></i> Convert to PDF
          </button>

          <a class="control-btn download-btn" id="downloadBtn" download="compressed_document.pdf">
            <i class="fas fa-download"></i> Download PDF
          </a>
        </div>

        <div class="loading" id="loading">
          <div class="spinner"></div>
          <p>Optimizing and converting files to PDF...</p>
          <p id="loadingDetail">Compressing images for smaller file size.</p>
        </div>
      </section>
    </div>

    <footer>
      <p>Client-side PDF Converter with Smart Compression &bull; No data leaves your computer</p>
      <p>Uses advanced image compression techniques to reduce PDF file size</p>
    </footer>
  </div>

  <script>
    // Global variables
    let files = [];
    const MAX_FILE_SIZE_NORMAL = 5 * 1024 * 1024; // 5MB
    const MAX_TOTAL_SIZE = 100 * 1024 * 1024; // 100MB
    const MAX_FILES = 30;

    // Compression settings
    let settings = {
      quality: 0.8,
      maxWidth: 1200,
      compressionMode: 'balanced',
      pdfFormat: 'a4',
      optimizeImages: true,
      grayscale: false,
      orientation: 'portrait',
      margin: 20,
      spacing: 15,
      fontSize: 12,
      pageNumbers: true,
      fileHeaders: true
    };

    // DOM Elements
    const dropArea = document.getElementById('dropArea');
    const fileInput = document.getElementById('fileInput');
    const browseBtn = document.getElementById('browseBtn');
    const fileInfo = document.getElementById('fileInfo');
    const fileList = document.getElementById('fileList');
    const previewContainer = document.getElementById('previewContainer');
    const emptyPreview = document.getElementById('emptyPreview');
    const reorderBtn = document.getElementById('reorderBtn');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const loading = document.getElementById('loading');
    const loadingDetail = document.getElementById('loadingDetail');
    const memoryWarning = document.getElementById('memoryWarning');
    const statsPanel = document.getElementById('statsPanel');

    // Settings elements
    const qualitySlider = document.getElementById('qualitySlider');
    const qualityValue = document.getElementById('qualityValue');
    const qualityBadge = document.getElementById('qualityBadge');
    const widthSlider = document.getElementById('widthSlider');
    const widthValue = document.getElementById('widthValue');
    const compressionMode = document.getElementById('compressionMode');
    const pdfFormat = document.getElementById('pdfFormat');
    const optimizeImages = document.getElementById('optimizeImages');
    const grayscale = document.getElementById('grayscale');
    const sizeEstimate = document.getElementById('sizeEstimate');
    const estimatedSize = document.getElementById('estimatedSize');

    // Tab elements
    const compressionTab = document.getElementById('compressionTab');
    const layoutTab = document.getElementById('layoutTab');
    const compressionSettings = document.getElementById('compressionSettings');
    const layoutSettings = document.getElementById('layoutSettings');

    // Stats elements
    const totalFiles = document.getElementById('totalFiles');
    const totalSize = document.getElementById('totalSize');
    const estimatedPDF = document.getElementById('estimatedPDF');
    const compressionRate = document.getElementById('compressionRate');

    // Initialize event listeners
    function init() {
      browseBtn.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', handleFileSelect);
      dropArea.addEventListener('dragover', handleDragOver);
      dropArea.addEventListener('drop', handleDrop);
      convertBtn.addEventListener('click', convertToPDF);
      reorderBtn.addEventListener('click', toggleReorderMode);

      // Settings event listeners
      qualitySlider.addEventListener('input', updateQuality);
      widthSlider.addEventListener('input', updateMaxWidth);
      compressionMode.addEventListener('change', updateCompressionMode);
      pdfFormat.addEventListener('change', updatePdfFormat);
      optimizeImages.addEventListener('change', updateOptimizeImages);
      grayscale.addEventListener('change', updateGrayscale);

      // Tab event listeners
      compressionTab.addEventListener('click', () => switchTab('compression'));
      layoutTab.addEventListener('click', () => switchTab('layout'));

      // Load saved settings from localStorage
      loadSettings();

      // Update UI with initial settings
      updateQuality();
      updateMaxWidth();
    }

    // Load saved settings from localStorage
    function loadSettings() {
      const savedSettings = localStorage.getItem('pdfConverterSettings');
      if (savedSettings) {
        const saved = JSON.parse(savedSettings);
        settings = { ...settings, ...saved };

        // Update UI elements with saved settings
        qualitySlider.value = settings.quality;
        widthSlider.value = settings.maxWidth;
        compressionMode.value = settings.compressionMode;
        pdfFormat.value = settings.pdfFormat;
        optimizeImages.checked = settings.optimizeImages;
        grayscale.checked = settings.grayscale;

        updateQuality();
        updateMaxWidth();
      }
    }

    // Save settings to localStorage
    function saveSettings() {
      localStorage.setItem('pdfConverterSettings', JSON.stringify(settings));
    }

    // Switch between tabs
    function switchTab(tab) {
      if (tab === 'compression') {
        compressionTab.classList.add('active');
        layoutTab.classList.remove('active');
        compressionSettings.classList.add('active');
        layoutSettings.classList.remove('active');
      } else {
        compressionTab.classList.remove('active');
        layoutTab.classList.add('active');
        compressionSettings.classList.remove('active');
        layoutSettings.classList.add('active');
      }
    }

    // Update quality setting
    function updateQuality() {
      settings.quality = parseFloat(qualitySlider.value);
      qualityValue.textContent = `${Math.round(settings.quality * 100)}%`;

      // Update quality badge
      if (settings.quality >= 0.9) {
        qualityBadge.textContent = 'High';
        qualityBadge.style.backgroundColor = '#4caf50';
      } else if (settings.quality >= 0.7) {
        qualityBadge.textContent = 'Medium';
        qualityBadge.style.backgroundColor = '#ff9800';
      } else {
        qualityBadge.textContent = 'Low';
        qualityBadge.style.backgroundColor = '#f44336';
      }

      updateSizeEstimate();
      saveSettings();
    }

    // Update max width setting
    function updateMaxWidth() {
      settings.maxWidth = parseInt(widthSlider.value);
      widthValue.textContent = `${settings.maxWidth}px`;
      updateSizeEstimate();
      saveSettings();
    }

    // Update compression mode
    function updateCompressionMode() {
      settings.compressionMode = compressionMode.value;
      updateSizeEstimate();
      saveSettings();
    }

    // Update PDF format
    function updatePdfFormat() {
      settings.pdfFormat = pdfFormat.value;
      saveSettings();
    }

    // Update optimize images setting
    function updateOptimizeImages() {
      settings.optimizeImages = optimizeImages.checked;
      updateSizeEstimate();
      saveSettings();
    }

    // Update grayscale setting
    function updateGrayscale() {
      settings.grayscale = grayscale.checked;
      updateSizeEstimate();
      saveSettings();
    }

    // Handle drag over event
    function handleDragOver(e) {
      e.preventDefault();
      e.stopPropagation();
      dropArea.classList.add('highlight');
    }

    // Handle drop event
    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      dropArea.classList.remove('highlight');

      const droppedFiles = e.dataTransfer.files;
      processFiles(droppedFiles);
    }

    // Handle file selection via input
    function handleFileSelect(e) {
      const selectedFiles = e.target.files;
      processFiles(selectedFiles);
    }

    // Process uploaded files
    function processFiles(fileArray) {
      // Convert FileList to array
      const newFiles = Array.from(fileArray);

      // Check if adding new files would exceed limits
      if (files.length + newFiles.length > MAX_FILES) {
        alert(`You can only upload up to ${MAX_FILES} files. You already have ${files.length} files.`);
        return;
      }

      // Calculate total size
      let totalSize = files.reduce((sum, file) => sum + file.size, 0);

      // Check each new file
      for (const file of newFiles) {
        // Check file type
        const fileType = file.type;
        const fileName = file.name.toLowerCase();

        // Check if file is supported
        const isImage = fileType.startsWith('image/');
        const isText = fileType === 'text/plain' || fileName.endsWith('.txt');

        if (!isImage && !isText) {
          alert(`File "${file.name}" is not supported. Please upload images or text files only.`);
          continue;
        }

        // Check individual file size
        if (file.size > 15 * 1024 * 1024) {
          alert(`File "${file.name}" is too large (max 15MB).`);
          continue;
        }

        // Check total size
        totalSize += file.size;
        if (totalSize > MAX_TOTAL_SIZE) {
          alert(`Adding "${file.name}" would exceed the total size limit of 100MB.`);
          continue;
        }

        // Add file to array with metadata
        files.push({
          file: file,
          id: Date.now() + Math.random(),
          type: isImage ? 'image' : 'text',
          name: file.name,
          size: file.size,
          preview: null,
          compressed: false,
          compressedSize: file.size
        });
      }

      // Show memory warning if any file is large
      const hasLargeFile = files.some(f => f.size > MAX_FILE_SIZE_NORMAL);
      memoryWarning.classList.toggle('active', hasLargeFile);

      // Update UI
      updateFileList();
      updatePreview();
      updateStats();
      updateSizeEstimate();
      fileInput.value = ''; // Reset input
    }

    // Update file list UI
    function updateFileList() {
      if (files.length === 0) {
        fileInfo.classList.remove('active');
        statsPanel.classList.remove('active');
        return;
      }

      fileInfo.classList.add('active');
      statsPanel.classList.add('active');
      fileList.innerHTML = '';

      files.forEach((fileData, index) => {
        const li = document.createElement('li');
        li.className = 'file-item';
        li.dataset.id = fileData.id;

        // Format file size
        const size = formatFileSize(fileData.size);

        li.innerHTML = `
                    <div class="file-name">
                        <i class="fas ${fileData.type === 'image' ? 'fa-file-image' : 'fa-file-alt'}"></i>
                        <span>${fileData.name}</span>
                        ${fileData.compressed ? '<span style="color: green; font-size: 0.8rem;">(compressed)</span>' : ''}
                    </div>
                    <div class="file-size">${size}</div>
                    <button class="remove-file" onclick="removeFile('${fileData.id}')">
                        <i class="fas fa-times"></i>
                    </button>
                `;

        fileList.appendChild(li);
      });
    }

    // Remove file from list
    function removeFile(id) {
      files = files.filter(f => f.id !== id);
      updateFileList();
      updatePreview();
      updateStats();
      updateSizeEstimate();

      // Hide memory warning if no large files remain
      const hasLargeFile = files.some(f => f.size > MAX_FILE_SIZE_NORMAL);
      memoryWarning.classList.toggle('active', hasLargeFile);
    }

    // Update preview section
    function updatePreview() {
      if (files.length === 0) {
        emptyPreview.style.display = 'block';
        previewContainer.innerHTML = '<p id="emptyPreview">No files added yet. Upload files to see preview here.</p>';
        return;
      }

      emptyPreview.style.display = 'none';
      previewContainer.innerHTML = '';

      files.forEach((fileData, index) => {
        const previewItem = document.createElement('div');
        previewItem.className = 'preview-item';
        previewItem.dataset.id = fileData.id;

        // Generate preview content based on file type
        let previewContent = '';

        if (fileData.type === 'image') {
          // Create image preview
          if (!fileData.preview) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const img = document.createElement('img');
              img.src = e.target.result;
              img.className = 'preview-img';

              const contentDiv = previewItem.querySelector('.preview-content');
              contentDiv.innerHTML = '';
              contentDiv.appendChild(img);
            };
            reader.readAsDataURL(fileData.file);
            previewContent = '<p>Loading image preview...</p>';
          } else {
            previewContent = `<img src="${fileData.preview}" class="preview-img" alt="${fileData.name}">`;
          }
        } else {
          // Create text preview
          if (!fileData.preview) {
            const reader = new FileReader();
            reader.onload = function (e) {
              const text = e.target.result;
              // Limit preview length
              const previewText = text.length > 1000 ? text.substring(0, 1000) + '...' : text;

              const contentDiv = previewItem.querySelector('.preview-content');
              contentDiv.innerHTML = `<div class="preview-text">${escapeHtml(previewText)}</div>`;
            };
            reader.readAsText(fileData.file);
            previewContent = '<p>Loading text preview...</p>';
          } else {
            previewContent = `<div class="preview-text">${escapeHtml(fileData.preview)}</div>`;
          }
        }

        previewItem.innerHTML = `
                    <div class="preview-item-header">
                        <div class="file-name">
                            <span class="file-type-icon">
                                <i class="fas ${fileData.type === 'image' ? 'fa-image' : 'fa-file-alt'}"></i>
                            </span>
                            <span>${fileData.name}</span>
                        </div>
                        <div class="item-actions">
                            <button class="move-btn" onclick="moveItemUp('${fileData.id}')" ${index === 0 ? 'disabled' : ''}>
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button class="move-btn" onclick="moveItemDown('${fileData.id}')" ${index === files.length - 1 ? 'disabled' : ''}>
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button class="remove-file" onclick="removeFile('${fileData.id}')">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="preview-content">
                        ${previewContent}
                    </div>
                `;

        previewContainer.appendChild(previewItem);
      });
    }

    // Move item up in the list
    function moveItemUp(id) {
      const index = files.findIndex(f => f.id === id);
      if (index > 0) {
        // Swap with previous item
        [files[index], files[index - 1]] = [files[index - 1], files[index]];
        updatePreview();
        updateFileList();
      }
    }

    // Move item down in the list
    function moveItemDown(id) {
      const index = files.findIndex(f => f.id === id);
      if (index < files.length - 1) {
        // Swap with next item
        [files[index], files[index + 1]] = [files[index + 1], files[index]];
        updatePreview();
        updateFileList();
      }
    }

    // Toggle reorder mode
    function toggleReorderMode() {
      const moveButtons = document.querySelectorAll('.move-btn');
      const isHidden = moveButtons[0].style.display === 'none';

      moveButtons.forEach(btn => {
        btn.style.display = isHidden ? 'inline-block' : 'none';
      });

      reorderBtn.innerHTML = isHidden ?
        '<i class="fas fa-random"></i> Done Reordering' :
        '<i class="fas fa-random"></i> Reorder Files';
    }

    // Update statistics panel
    function updateStats() {
      if (files.length === 0) {
        statsPanel.classList.remove('active');
        return;
      }

      const totalFilesCount = files.length;
      const originalTotalSize = files.reduce((sum, f) => sum + f.size, 0);

      totalFiles.textContent = totalFilesCount;
      totalSize.textContent = formatFileSize(originalTotalSize);

      // Estimate compressed size
      let estimatedTotalSize = 0;
      files.forEach(file => {
        if (file.type === 'image') {
          // Estimate image compression
          let compressionFactor = 0.7; // Default
          if (settings.compressionMode === 'high') compressionFactor = 0.3;
          if (settings.compressionMode === 'low') compressionFactor = 0.9;
          if (settings.compressionMode === 'textOnly') compressionFactor = 0.1;

          // Apply quality setting
          compressionFactor *= settings.quality;

          // Apply grayscale setting
          if (settings.grayscale) compressionFactor *= 0.7;

          estimatedTotalSize += file.size * compressionFactor;
        } else {
          // Text files add minimal size
          estimatedTotalSize += file.size * 0.1; // Text compression is very efficient
        }
      });

      // Add PDF overhead (about 50KB)
      estimatedTotalSize += 50 * 1024;

      estimatedPDF.textContent = formatFileSize(estimatedTotalSize);

      // Calculate compression rate
      const reduction = Math.max(0, 100 - (estimatedTotalSize / originalTotalSize * 100));
      compressionRate.textContent = `${Math.round(reduction)}%`;
    }

    // Update size estimate
    function updateSizeEstimate() {
      if (files.length === 0) {
        sizeEstimate.classList.remove('active');
        return;
      }

      sizeEstimate.classList.add('active');
      updateStats();
    }

    // Convert files to PDF with compression
    async function convertToPDF() {
      if (files.length === 0) {
        alert('Please add at least one file to convert.');
        return;
      }

      // Show loading indicator
      loading.classList.add('active');
      convertBtn.disabled = true;

      try {
        // Initialize jsPDF
        const { jsPDF } = window.jspdf;

        // Set PDF format based on settings
        let pdfFormat = 'a4';
        let orientation = 'portrait';

        if (settings.pdfFormat === 'letter') {
          pdfFormat = 'letter';
        }

        if (settings.orientation === 'landscape') {
          orientation = 'landscape';
        } else if (settings.orientation === 'auto') {
          // Auto-detect based on images
          const hasWideImages = await checkForWideImages();
          orientation = hasWideImages ? 'landscape' : 'portrait';
        }

        const pdf = new jsPDF(orientation, 'mm', pdfFormat);

        // Set initial y position in mm
        const margin = settings.margin;
        let yPos = margin;
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const contentWidth = pageWidth - 2 * margin;

        // Track page number
        let pageNum = 1;

        // Process each file
        for (let i = 0; i < files.length; i++) {
          const fileData = files[i];
          loadingDetail.textContent = `Optimizing file ${i + 1} of ${files.length}: ${fileData.name}`;

          // Add file name header if enabled
          if (settings.fileHeaders && yPos > margin) {
            yPos += 5;
            pdf.setFontSize(10);
            pdf.setFont("helvetica", "normal");
            pdf.setTextColor(100, 100, 100);
            pdf.text(`File: ${fileData.name}`, margin, yPos);
            yPos += 8;
          }

          // Process based on file type
          if (fileData.type === 'image') {
            await processImageWithCompression(pdf, fileData, yPos, margin, contentWidth, pageHeight);

            // Update y position (we'll get actual height from processImageWithCompression)
            const imgHeight = await getImageHeight(fileData, contentWidth);
            yPos += imgHeight + settings.spacing;

            // Check if we need a new page
            if (yPos > pageHeight - margin && i < files.length - 1) {
              addPageFooter(pdf, pageNum, pageWidth, pageHeight);
              pdf.addPage();
              pageNum++;
              yPos = margin;
            }
          } else {
            await processTextFileCompressed(pdf, fileData, yPos, margin, contentWidth, pageHeight);
            // Update y position (we'll get actual height from processTextFileCompressed)
            const textHeight = await getTextHeight(fileData, contentWidth);
            yPos += textHeight + settings.spacing;

            // Check if we need a new page
            if (yPos > pageHeight - margin && i < files.length - 1) {
              addPageFooter(pdf, pageNum, pageWidth, pageHeight);
              pdf.addPage();
              pageNum++;
              yPos = margin;
            }
          }

          // Give browser time to breathe between files
          await new Promise(resolve => setTimeout(resolve, 50));
        }

        // Add final page footer
        addPageFooter(pdf, pageNum, pageWidth, pageHeight);

        // Generate PDF blob
        const pdfBlob = pdf.output('blob');
        const pdfUrl = URL.createObjectURL(pdfBlob);

        // Show final file size
        const finalSize = formatFileSize(pdfBlob.size);
        loadingDetail.innerHTML = `Conversion complete! Final PDF size: <strong>${finalSize}</strong>`;

        // Update download button
        downloadBtn.href = pdfUrl;
        downloadBtn.style.display = 'flex';
        downloadBtn.download = `compressed_document_${Date.now()}.pdf`;

        // Scroll to download button
        setTimeout(() => {
          downloadBtn.scrollIntoView({ behavior: 'smooth' });
        }, 500);

      } catch (error) {
        console.error('Error converting to PDF:', error);
        alert('Error converting files to PDF. Please try again with smaller files or adjust compression settings.');
      } finally {
        // Hide loading indicator
        setTimeout(() => {
          loading.classList.remove('active');
          convertBtn.disabled = false;
        }, 1000);
      }
    }

    // Process image with compression
    async function processImageWithCompression(pdf, fileData, yPos, margin, contentWidth, pageHeight) {
      return new Promise(async (resolve) => {
        try {
          // Create canvas for image processing
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Load image
          const img = new Image();
          const imgUrl = URL.createObjectURL(fileData.file);

          img.onload = async function () {
            try {
              // Calculate new dimensions based on maxWidth setting
              let width = img.width;
              let height = img.height;

              // Apply max width constraint
              if (width > settings.maxWidth) {
                height = (height * settings.maxWidth) / width;
                width = settings.maxWidth;
              }

              // Check if image fits on current page
              const mmPerPixel = contentWidth / width;
              const imgHeightMM = height * mmPerPixel;

              if (yPos + imgHeightMM > pageHeight - margin) {
                // Image doesn't fit, add new page
                pdf.addPage();
                yPos = margin;
              }

              // Set canvas dimensions
              canvas.width = width;
              canvas.height = height;

              // Apply grayscale if enabled
              if (settings.grayscale) {
                ctx.filter = 'grayscale(100%)';
              }

              // Draw image on canvas
              ctx.drawImage(img, 0, 0, width, height);

              // Apply compression based on settings
              let quality = settings.quality;

              // Adjust quality based on compression mode
              if (settings.compressionMode === 'high') {
                quality *= 0.6;
              } else if (settings.compressionMode === 'low') {
                quality = Math.min(quality * 1.2, 1);
              } else if (settings.compressionMode === 'textOnly') {
                // For textOnly mode, skip images
                pdf.setFontSize(12);
                pdf.text(`[Image: ${fileData.name} - Skipped in text-only mode]`, margin, yPos);
                URL.revokeObjectURL(imgUrl);
                resolve();
                return;
              }

              // Convert canvas to data URL with compression
              const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);

              // Add compressed image to PDF
              pdf.addImage(compressedDataUrl, 'JPEG', margin, yPos, contentWidth, imgHeightMM);

              // Mark file as compressed
              fileData.compressed = true;
              fileData.compressedSize = Math.round(compressedDataUrl.length * 0.75); // Approximate size

            } catch (error) {
              console.error('Error processing image:', error);
              // Fallback: add placeholder
              pdf.setFontSize(12);
              pdf.text(`[Image: ${fileData.name} - Error processing]`, margin, yPos);
            }

            // Clean up
            URL.revokeObjectURL(imgUrl);
            resolve();
          };

          img.onerror = function () {
            // If image fails to load, add placeholder
            pdf.setFontSize(12);
            pdf.text(`[Image: ${fileData.name} - Could not load]`, margin, yPos);
            URL.revokeObjectURL(imgUrl);
            resolve();
          };

          img.src = imgUrl;

        } catch (error) {
          console.error('Error in image processing:', error);
          pdf.setFontSize(12);
          pdf.text(`[Image: ${fileData.name} - Processing error]`, margin, yPos);
          resolve();
        }
      });
    }

    // Process text file with compression
    async function processTextFileCompressed(pdf, fileData, yPos, margin, contentWidth, pageHeight) {
      try {
        const text = await readFileAsText(fileData.file);

        // Set font
        pdf.setFontSize(settings.fontSize);
        pdf.setFont("helvetica", "normal");
        pdf.setTextColor(0, 0, 0);

        // Split text into lines that fit PDF width
        const textLines = pdf.splitTextToSize(text, contentWidth);

        // Add text line by line
        for (let line of textLines) {
          // Check if we need a new page
          if (yPos > pageHeight - margin) {
            pdf.addPage();
            yPos = margin;
          }

          pdf.text(line, margin, yPos);
          yPos += settings.fontSize * 0.35; // Approximate line height in mm
        }

      } catch (error) {
        console.error('Error processing text file:', error);
        pdf.setFontSize(12);
        pdf.text(`[Text: ${fileData.name} - Error reading file]`, margin, yPos);
        yPos += 10;
      }
    }

    // Add page footer with page number
    function addPageFooter(pdf, pageNum, pageWidth, pageHeight) {
      if (!settings.pageNumbers) return;

      pdf.setFontSize(10);
      pdf.setFont("helvetica", "normal");
      pdf.setTextColor(100, 100, 100);

      const footerText = `Page ${pageNum}`;
      const textWidth = pdf.getTextWidth(footerText);

      pdf.text(footerText, pageWidth - margin - textWidth, pageHeight - 10);
    }

    // Check if any images are wider than tall (for auto orientation)
    async function checkForWideImages() {
      for (const fileData of files) {
        if (fileData.type === 'image') {
          const dimensions = await getImageDimensions(fileData.file);
          if (dimensions.width > dimensions.height * 1.2) {
            return true; // Found a wide image
          }
        }
      }
      return false;
    }

    // Get image dimensions
    function getImageDimensions(file) {
      return new Promise((resolve) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = function () {
          resolve({ width: img.width, height: img.height });
          URL.revokeObjectURL(url);
        };

        img.onerror = function () {
          resolve({ width: 800, height: 600 }); // Default fallback
          URL.revokeObjectURL(url);
        };

        img.src = url;
      });
    }

    // Get image height in mm for given content width
    async function getImageHeight(fileData, contentWidth) {
      const dimensions = await getImageDimensions(fileData.file);
      const aspectRatio = dimensions.height / dimensions.width;
      return contentWidth * aspectRatio;
    }

    // Get text height in mm for given content width
    async function getTextHeight(fileData, contentWidth) {
      const text = await readFileAsText(fileData.file);
      // Estimate: approximately 4 lines per 100 chars at 12pt font
      const approxLines = Math.ceil(text.length / 100) * 4;
      return approxLines * settings.fontSize * 0.35;
    }

    // Helper function to read file as text
    function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(e);
        reader.readAsText(file);
      });
    }

    // Helper function to format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';

      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));

      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Initialize the application
    init();
  </script>
</body>

</html>